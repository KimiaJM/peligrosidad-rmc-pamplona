import Util from"../../../TC/Util";import GML32 from"ol/format/GML32";import{createElementNS,makeChildAppender,makeSimpleNodeFactory,pushSerializeAndPop}from"ol/xml";import{writeStringTextNode}from"ol/format/xsd";import{transformExtentWithOptions}from"ol/format/Feature";import{Geometry}from"ol/geom";import Consts from"../../../TC/Consts.js";const TEXT_NODE="#text",getNameComponents=function(e){let[t,r]=e.split(":");return r||([t,r]=[r,t]),[t,r]};GML32.prototype.writeFeaturesNode=function(e,t){t=this.adaptOptions(t);const r=createElementNS(this.featureNS,"featureMembers");t.parentNode&&t.parentNode.appendChild(r);let i=this.featureNS;if(this.featureTypeMetadata?.origin===Consts.format.GML){this.featureTypeMetadata.originalMetadata?.featureTypes&&(this.featureType=Object.keys(this.featureTypeMetadata.originalMetadata.featureTypes)[0]);const e=this.featureType.substring(0,this.featureType.indexOf(":"));i=this.featureTypeMetadata.originalMetadata?.namespaces?.find((t=>t.prefix===e))?.value??this.featureNS}const s={srsName:this.srsName,hasZ:this.hasZ,curve:this.curve_,surface:this.surface_,multiSurface:this.multiSurface_,multiCurve:this.multiCurve_,featureNS:i,featureType:this.featureType};t&&Object.assign(s,t);const a=e.map((e=>{var t=e.clone();return t.id_=e.id_,t})).map((e=>{let t=e.getProperties();const r=[];for(var i in t)(i.indexOf(" ")>=0||/^\d/.test(i))&&r.push(i);return r.forEach((function(r){var i=r.replace(/ /g,"_");if(/^\d/.test(i)&&(i="_"+i),r!==i)for(;void 0!==t[i];)i+="_";e.set(i,t[r]),e.unset(r)})),e}));return this.writeFeatureMembers_(r,a,[s]),r},GML32.prototype.writeFeatureMembers_=function(e,t,r){const i=r[r.length-1],s=i.featureType,a=i.featureNS,o={};o[a]={},o[a][s]=makeChildAppender(this.writeFeatureElement,this),s.indexOf(":")>0&&(o[a][s.substring(s.indexOf(":")+1)]=o[a][s]);const n=Object.assign({},i);n.node=e,pushSerializeAndPop(n,o,makeSimpleNodeFactory(s,a),t,r)},GML32.prototype.writeFeatures=function(e,t){const r=t?.featureTypeMetadata;this.hasZ=e.some((e=>e.getGeometry()?.getLayout?.().length>2));const i=function(e){for(const t in e){const r=e[t];void 0===r?e[t]="":null!==r&&"object"==typeof r&&i(r)}};let s=e.map((e=>{const t=e.clone(),r=Util.extend(!0,!0,{},e.getProperties());return i(r),t.setProperties(r),t.setId(e.getId()),t}));if(r?.origin===Consts.format.GML){const e=t=>{const r=[];for(let i in t){const s=t[i];if("string"==typeof s.type)GML32.getGeometryType(s.type)&&r.push([i]);else if("object"==typeof s.type){const t=e(s.type);for(const e of t)r.push([i,...e])}}return r},[t,i]=Object.entries(r.originalMetadata.featureTypes)[0],[a]=getNameComponents(t),o=e(i);if(o.length&&o.every((e=>e.length>1))){const e=o[0],t=(e,t,r)=>{if(Object.prototype.hasOwnProperty.call(e,t))return e[t];if(t.indexOf(":")<0){const i=r+":"+t;if(Object.prototype.hasOwnProperty.call(e,i))return e[i]}};s=s.map((r=>{const i=Util.extend(!0,{},r.getProperties());let s=i;for(let r=0,i=e.length-1;r<i;r++)s=t(s,e[r],a);return s&&(s[e[e.length-1]]=r.getGeometry(),r.setProperties(i),r.unset(r.getGeometryName(),!0)),r}))}}const a=this.writeFeaturesNode(s,t),o=createElementNS("http://www.opengis.net/wfs","FeatureCollection");r?.origin===Consts.format.GML?o.setAttributeNS("http://www.w3.org/2001/XMLSchema-instance","xsi:schemaLocation",r.originalMetadata.namespaces.filter((e=>e.schemaLocation)).map((e=>`${e.value} ${e.schemaLocation}`)).join(" ")):o.setAttributeNS("http://www.w3.org/2001/XMLSchema-instance","xsi:schemaLocation",this.schemaLocation),o.appendChild(a);let n=this.xmlSerializer_.serializeToString(o);const l=r?.originalMetadata?.namespaces||[{prefix:"gml",value:"http://www.opengis.net/gml/3.2"}];let p="<FeatureCollection";for(const e of l){const t=` xmlns:${e.prefix}="${e.value}"`;p+=t,n=n.replaceAll(t,"")}return n=n.replace("<FeatureCollection",p),["MultiPolygon","MultiSurface","surfaceMember","Point","Polygon","Surface","LineString","Curve","MultiLineString","MultiPoint","MultiCurve","curveMember","exterior","interior","LinearRing","posList","pos","boundedBy"].forEach((e=>{n=n.replaceAll("<"+e+' xmlns="http://www.opengis.net/gml"',"<gml:"+e),n=n.replaceAll("<"+e,"<gml:"+e),n=n.replaceAll("/"+e,"/gml:"+e)})),n};const getNamespaceURI=function(e,t){const[r]=getNameComponents(e);let i=t;return this.featureTypeMetadata&&(i=this.featureTypeMetadata.originalMetadata?.namespaces?.find((e=>e.prefix===r))?.value??i),i};GML32.prototype.writeFeatureElement=function(e,t,r){const i=t.getId();i&&e.setAttribute("fid",i);const s=r[r.length-1],a=s.featureNS,o=t.getGeometryName();s.serializers||(s.serializers={},s.serializers[a]={});const n=[],l=[];if(t.hasProperties()){const e=t=>{if(t instanceof Geometry)return t;if(!t||"object"!=typeof t||Array.isArray(t))return t;const r={};return Object.entries(t).forEach((([i,s])=>{if(i.indexOf(ATTRIBUTE_NAME_MARK)>0){const[e,a]=i.split(ATTRIBUTE_NAME_MARK);r[e]&&Object.prototype.hasOwnProperty.call(r[e],"#text")||(r[e]={[TEXT_NODE]:t[e]}),r[e][ATTRIBUTE_NAME_MARK+a]=s}else Object.prototype.hasOwnProperty.call(r,i)||(r[i]=e(s))})),r},r=e(t.getProperties());for(const e in r){const t=r[e];if(Array.isArray(t)&&"boundedBy"!==e&&"gml:boundedBy"!==e?(t.forEach((e=>l.push(e))),t.forEach((()=>n.push(e)))):(n.push(e),l.push(t)),e==o||"function"==typeof t?.getSimplifiedGeometry)e in s.serializers[a]||(s.serializers[a][e]=makeChildAppender(this.writeGeometryElement,this));else{const t=getNamespaceURI.call(this,e,a);s.serializers[t]??={},e in s.serializers[t]||("boundedBy"===e||"gml:boundedBy"===e?s.serializers[t]["gml:boundedBy"]=makeChildAppender(this.writeBoundedByElement):s.serializers[t][e]=makeChildAppender(this.writeFeaturePropertyNode),e.indexOf(":")>0&&(s.serializers[t][e.substring(e.indexOf(":")+1)]=s.serializers[t][e]))}}}const p=Object.assign({},s);p.node=e,l.forEach(((e,t)=>{const i=n[t],o=getNamespaceURI.call(this,i,a),l=this.featureTypeMetadata?.originalMetadata?.namespaces?.find((e=>e.value===o))?.prefix,c=l&&i.indexOf(":")<0?l+":"+i:i;pushSerializeAndPop(p,s.serializers,makeSimpleNodeFactory(c,o),[e],r,[i],this)}))},GML32.prototype.writeBoundedByElement=function(e,t,r){const i=r[r.length-1],s=Object.assign({},i);let a;s.node=e,Array.isArray(t)&&(a=transformExtentWithOptions(t,i)),pushSerializeAndPop(s,this.GEOMETRY_SERIALIZERS,this.GEOMETRY_NODE_FACTORY_,[a],r,["Envelope"],this)};const ATTRIBUTE_NAME_MARK="@",removeAttributeNameMark=e=>e.substring(e.indexOf(ATTRIBUTE_NAME_MARK)+1);GML32.prototype.writeFeaturePropertyNode=function(e,t,r){const i=r[r.length-1],s=i.featureNS,a=Object.assign({},i);if(a.node=e,null===t)e.setAttribute("xsi:nil","true");else if("object"!=typeof t||Array.isArray(t))writeStringTextNode(e,t);else for(let o in t){const n=t[o],l=getNamespaceURI.call(this,o,s);let[p,c]=getNameComponents(removeAttributeNameMark(o));p??=this.featureTypeMetadata?.originalMetadata?.namespaces?.find((e=>e.value===l))?.prefix;const u=p?p+":"+c:c;i.serializers[l]??={},"#text"===o?null===n?e.setAttribute("xsi:nil","true"):void 0!==n&&writeStringTextNode(e,n):o.startsWith(ATTRIBUTE_NAME_MARK)?e.setAttribute(removeAttributeNameMark(o),n||""):(o in i.serializers[l]||(i.serializers[l][o]=n instanceof Geometry?makeChildAppender(this.writeGeometryElement,this):makeChildAppender(this.writeFeaturePropertyNode),i.serializers[l][c]=i.serializers[l][o]),pushSerializeAndPop(a,i.serializers,makeSimpleNodeFactory(u,l),[void 0===n?"":n],r,[o],this))}[...e.attributes].slice().forEach((t=>{t.name.startsWith("xmlns")&&e.removeAttribute(t)}))};export default GML32;